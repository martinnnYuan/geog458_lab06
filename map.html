<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Traffic Safety in Seattle - 2022</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <link href="https://fonts.googleapis.com/css?family=Titillium+Web|Oswald" rel="stylesheet">
    <link href="https://unpkg.com/maplibre-gl@3.6.0/dist/maplibre-gl.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.7.20/c3.min.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Titillium Web', serif;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        #info {
            z-index: 1000;
            position: absolute;
            width: 500px;
            max-width: calc(100% - 20px);
            top: 1%;
            bottom: 1%;
            left: .5%;
            padding: 18px 15px 18px 15px;
            background: #343a40;
            color: white;
            overflow-y: auto;
            border-radius: 4px;
        }

        #info a {
            color: lightgray;
        }

        #info a:hover {
            color: white;
            opacity: 0.7;
        }

        #title {
            font-size: 25px;
            font-family: 'Oswald', sans-serif;
            margin-bottom: 14px;
        }

        #title span {
            font-size: 14px;
            float: right;
            margin-right: 10px;
            margin-top: 8px;
        }

        #desc {
            text-align: center;
            color: lightgray;
            font-size: medium;
            font-weight: bold;
            margin-bottom: 0;
        }

        #collision-count {
            margin: 0;
            text-align: center;
            color: orange;
            font-size: 50px;
            line-height: 1.1;
        }

        #severity-chart {
            margin-top: 10px;
        }

        .card {
            margin-top: 12px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 4px;
        }

        .section-title {
            margin: 0 0 8px 0;
            font-family: 'Oswald', sans-serif;
            font-size: 17px;
            letter-spacing: 0.4px;
        }

        .control-label {
            display: block;
            margin: 6px 0;
            color: #e9ecef;
            font-size: 14px;
        }

        .control-label input {
            margin-right: 8px;
        }

        .btn {
            margin-top: 8px;
            border: 1px solid #adb5bd;
            background: transparent;
            color: #f8f9fa;
            padding: 6px 10px;
            border-radius: 3px;
            cursor: pointer;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .btn:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        #progress {
            margin: 8px 0 0 0;
            font-size: 12px;
            color: #adb5bd;
        }

        #risk-list {
            max-height: 240px;
            overflow-y: auto;
        }

        .risk-item {
            border-bottom: 1px solid rgba(255, 255, 255, 0.15);
            padding: 6px 0;
            cursor: pointer;
        }

        .risk-item:last-child {
            border-bottom: 0;
        }

        .risk-item:hover {
            color: #ffd166;
        }

        .risk-meta {
            font-size: 12px;
            color: #ced4da;
        }

        #footer {
            margin-top: 12px;
            margin-right: 4px;
            font-size: 13px;
            line-height: 150%;
            color: lightgray;
        }

        #legend {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 180px;
            background: #fff;
            margin-right: 20px;
            margin-bottom: 40px;
            padding: 10px 12px;
            border-radius: 3px;
            font-family: 'Open Sans', sans-serif;
            color: #1f2933;
            font-size: 13px;
        }

        .break {
            position: relative;
            margin: 0;
            padding: 0;
            min-height: 20px;
        }

        .dot {
            display: inline-block;
            margin-top: 4px;
            border-radius: 50%;
            opacity: 0.8;
        }

        .dot-label {
            position: absolute;
            top: 0;
            right: 0;
            font-style: italic;
            color: #1f2933;
        }

        .line-swatch {
            display: inline-block;
            width: 24px;
            height: 4px;
            margin-right: 6px;
            vertical-align: middle;
            border-radius: 2px;
        }

        .c3 text {
            fill: #e9ecef;
            font-size: 11px;
        }

        .c3-axis path,
        .c3-axis line,
        .c3-grid line {
            stroke: rgba(255, 255, 255, 0.25);
        }

        .maplibregl-popup-content {
            font-family: 'Titillium Web', serif;
            color: #111827;
        }

        @media (max-width: 900px) {
            #info {
                width: calc(100% - 20px);
                left: 10px;
                right: 10px;
                top: 10px;
                bottom: auto;
                max-height: 62%;
            }

            #legend {
                right: 8px;
                margin-right: 0;
                margin-bottom: 10px;
            }
        }
    </style>
    <script src="https://unpkg.com/maplibre-gl@3.6.0/dist/maplibre-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/proj4@2.11.0/dist/proj4.js"></script>
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.7.20/c3.min.js"></script>
</head>

<body>
    <div id="info">
        <div id="title">
            Traffic Safety in Seattle - 2022
            <span><a href="https://github.com/jakobzhao/geog458" target="_blank"><i class="bi bi-github"></i></a></span>
            <span><a href="https://www.seattle.gov/transportation" target="_blank"><i class="bi bi-globe"></i></a></span>
            <span id="reset"><a href="#">reset</a></span>
        </div>

        <div id="count" class="card">
            <h5 id="desc"># Collisions in the displaying region</h5>
            <p id="collision-count">0</p>
        </div>

        <div id="severity-chart"></div>

        <div class="card">
            <h5 class="section-title">Layers & Risk</h5>
            <label class="control-label"><input type="checkbox" id="toggle-volume" checked>Traffic volume (AWDT)</label>
            <label class="control-label"><input type="checkbox" id="toggle-risk" checked>Traffic risk index</label>
            <label class="control-label"><input type="checkbox" id="toggle-collisions" checked>Collisions</label>
            <button id="compute-risk" class="btn">Compute risk index</button>
            <p id="progress">Risk not computed yet.</p>
        </div>

        <div class="card">
            <h5 class="section-title">Top Risk Segments</h5>
            <div id="risk-list">Risk not computed yet.</div>
        </div>

        <div id="footer">
            Data sources: 2022 SDOT collisions and traffic flow counts. Collision dots are styled by severity; the risk
            layer is computed as crashes divided by (AWDT + 1) and then symbolized by quantiles.
        </div>
    </div>

    <div id="map"></div>
    <div id="legend"></div>

    <script>
        const collisionsUrl = 'assets/2022_SDOT_Collisions_Cleaned_CRS.geojson';
        const flowUrl = 'assets/2022_traffic_flow_counts_cleaned.geojson';

        const proj2926 = '+proj=lcc +lat_1=47.5 +lat_2=48.73333333333333 +lat_0=47 +lon_0=-120.8333333333333 +x_0=500000 +y_0=0 +datum=NAD83 +units=us-ft +no_defs';
        const toWgs84 = coordinates => proj4(proj2926, proj4.WGS84, coordinates);

        const initialView = {
            center: [-122.3321, 47.6062],
            zoom: 11.2
        };

        let map = null;
        let flowsWgs = null;
        let collisionsWgs = null;
        let severityChart = null;

        const legend = document.getElementById('legend');
        const collisionGrades = ['Fatal', 'Serious', 'Other'];
        const collisionColors = ['#d7191c', '#fdae61', '#2b83ba'];
        const collisionRadii = [10, 8, 6];

        const labels = ['<strong>Legend</strong>'];
        for (let i = 0; i < collisionGrades.length; i += 1) {
            const radius = collisionRadii[i];
            labels.push(
                '<p class="break"><i class="dot" style="background:' + collisionColors[i] + '; width: ' + (radius * 2) +
                'px; height: ' + (radius * 2) + 'px;"></i> <span class="dot-label" style="top: ' + radius + 'px;">' +
                collisionGrades[i] + '</span></p>'
            );
        }
        labels.push('<p style="margin:8px 0 0 0;"><span class="line-swatch" style="background:#00b4ff"></span>Volume</p>');
        labels.push('<p style="margin:4px 0 0 0;"><span class="line-swatch" style="background:#d73027"></span>High risk</p>');
        labels.push('<p style="text-align:right;font-size:10pt;margin:6px 0 0 0;">Source: SDOT</p>');
        legend.innerHTML = labels.join('');

        function reprojectGeometry(geometry) {
            if (!geometry) {
                return null;
            }
            if (geometry.type === 'Point') {
                return { type: 'Point', coordinates: toWgs84(geometry.coordinates) };
            }
            if (geometry.type === 'LineString') {
                return { type: 'LineString', coordinates: geometry.coordinates.map(toWgs84) };
            }
            if (geometry.type === 'MultiLineString') {
                return {
                    type: 'MultiLineString',
                    coordinates: geometry.coordinates.map(line => line.map(toWgs84))
                };
            }
            if (geometry.type === 'MultiPoint') {
                return { type: 'MultiPoint', coordinates: geometry.coordinates.map(toWgs84) };
            }
            return geometry;
        }

        function reprojectFeature(feature) {
            const geometry = reprojectGeometry(feature.geometry);
            if (!geometry) {
                return null;
            }
            return { ...feature, geometry };
        }

        async function loadData() {
            const [collisions, flows] = await Promise.all([
                fetch(collisionsUrl).then(response => response.json()),
                fetch(flowUrl).then(response => response.json())
            ]);

            collisionsWgs = {
                type: 'FeatureCollection',
                features: collisions.features.map(reprojectFeature).filter(Boolean)
            };

            flowsWgs = {
                type: 'FeatureCollection',
                features: flows.features.map(reprojectFeature).filter(Boolean)
            };
        }

        function getFeatureId(feature, index) {
            const properties = feature.properties || {};
            if (properties.OBJECTID !== undefined && properties.OBJECTID !== null) {
                return String(properties.OBJECTID);
            }
            if (properties.INCKEY !== undefined && properties.INCKEY !== null) {
                return String(properties.INCKEY);
            }
            const coordinates = feature.geometry && feature.geometry.coordinates ? feature.geometry.coordinates : [index];
            return coordinates.join(',');
        }

        function updateSummaryPanel() {
            if (!map || !map.getLayer('collisions')) {
                return;
            }

            const rendered = map.queryRenderedFeatures({ layers: ['collisions'] });
            const seen = new Set();
            const severityCounts = {
                fatal: 0,
                serious: 0,
                injury: 0,
                pdo: 0,
                other: 0
            };

            rendered.forEach((feature, index) => {
                const id = getFeatureId(feature, index);
                if (seen.has(id)) {
                    return;
                }
                seen.add(id);

                const severity = ((feature.properties && feature.properties.SEVERITYDESC) || '').toLowerCase();
                if (severity.includes('fatal')) {
                    severityCounts.fatal += 1;
                } else if (severity.includes('serious')) {
                    severityCounts.serious += 1;
                } else if (severity.includes('injury')) {
                    severityCounts.injury += 1;
                } else if (severity.includes('property damage')) {
                    severityCounts.pdo += 1;
                } else {
                    severityCounts.other += 1;
                }
            });

            document.getElementById('collision-count').textContent = seen.size.toLocaleString();

            const columns = [
                ['Fatal', severityCounts.fatal],
                ['Serious', severityCounts.serious],
                ['Injury', severityCounts.injury],
                ['PDO', severityCounts.pdo],
                ['Other', severityCounts.other]
            ];

            if (!severityChart) {
                severityChart = c3.generate({
                    bindto: '#severity-chart',
                    data: {
                        columns,
                        type: 'bar',
                        colors: {
                            Fatal: '#d7191c',
                            Serious: '#fdae61',
                            Injury: '#fee08b',
                            PDO: '#2b83ba',
                            Other: '#7b8b9f'
                        }
                    },
                    axis: {
                        x: {
                            type: 'category',
                            categories: ['Visible collisions']
                        },
                        y: {
                            tick: { format: d3.format('d') }
                        }
                    },
                    bar: {
                        width: { ratio: 0.8 }
                    },
                    legend: {
                        position: 'inset'
                    },
                    size: {
                        height: 210
                    },
                    padding: {
                        top: 8,
                        right: 8,
                        bottom: 8,
                        left: 36
                    }
                });
            } else {
                severityChart.load({ columns });
            }
        }

        function buildSpatialIndex(flowData, cellSize) {
            const index = new Map();
            const bboxes = [];

            flowData.features.forEach((feature, featureIndex) => {
                if (!feature.geometry) {
                    return;
                }

                const bbox = turf.bbox(feature);
                bboxes[featureIndex] = bbox;
                const minCellX = Math.floor(bbox[0] / cellSize);
                const maxCellX = Math.floor(bbox[2] / cellSize);
                const minCellY = Math.floor(bbox[1] / cellSize);
                const maxCellY = Math.floor(bbox[3] / cellSize);

                for (let cellX = minCellX; cellX <= maxCellX; cellX += 1) {
                    for (let cellY = minCellY; cellY <= maxCellY; cellY += 1) {
                        const key = `${cellX},${cellY}`;
                        if (!index.has(key)) {
                            index.set(key, []);
                        }
                        index.get(key).push(featureIndex);
                    }
                }
            });

            return { index, bboxes };
        }

        function computeRiskAsync(flowData, collisionData, callbacks) {
            const crashCounts = new Array(flowData.features.length).fill(0);
            const cellSize = 0.02;
            const searchRadiusCells = 1;
            const { index, bboxes } = buildSpatialIndex(flowData, cellSize);
            const total = collisionData.features.length;
            let current = 0;

            function step() {
                const frameStart = performance.now();

                while (current < total && performance.now() - frameStart < 20) {
                    const collision = collisionData.features[current];
                    current += 1;

                    if (!collision || !collision.geometry) {
                        continue;
                    }

                    const lng = collision.geometry.coordinates[0];
                    const lat = collision.geometry.coordinates[1];
                    const centerX = Math.floor(lng / cellSize);
                    const centerY = Math.floor(lat / cellSize);
                    const candidates = new Set();

                    for (let deltaX = -searchRadiusCells; deltaX <= searchRadiusCells; deltaX += 1) {
                        for (let deltaY = -searchRadiusCells; deltaY <= searchRadiusCells; deltaY += 1) {
                            const key = `${centerX + deltaX},${centerY + deltaY}`;
                            const matches = index.get(key);
                            if (matches) {
                                matches.forEach(id => candidates.add(id));
                            }
                        }
                    }

                    let nearestFeatureIndex = -1;
                    let nearestDistance = Infinity;

                    candidates.forEach(featureIndex => {
                        const flowFeature = flowData.features[featureIndex];
                        if (!flowFeature || !flowFeature.geometry) {
                            return;
                        }

                        const bbox = bboxes[featureIndex];
                        if (lng < bbox[0] - cellSize || lng > bbox[2] + cellSize || lat < bbox[1] - cellSize || lat > bbox[3] + cellSize) {
                            return;
                        }

                        const snapped = turf.nearestPointOnLine(
                            { type: flowFeature.geometry.type, coordinates: flowFeature.geometry.coordinates },
                            collision.geometry
                        );

                        if (!snapped || !snapped.properties || typeof snapped.properties.dist !== 'number') {
                            return;
                        }

                        if (snapped.properties.dist < nearestDistance) {
                            nearestDistance = snapped.properties.dist;
                            nearestFeatureIndex = featureIndex;
                        }
                    });

                    if (nearestFeatureIndex >= 0) {
                        crashCounts[nearestFeatureIndex] += 1;
                    }
                }

                if (callbacks.onProgress) {
                    callbacks.onProgress(current, total);
                }

                if (current < total) {
                    setTimeout(step, 0);
                    return;
                }

                const scores = flowData.features.map((feature, index) => {
                    const properties = feature.properties || {};
                    const volume = properties.AWDT || properties.ADT || 0;
                    const crashes = crashCounts[index];
                    const score = crashes / (volume + 1);

                    return {
                        index,
                        name: properties.STNAME_ORD || 'Segment',
                        volume,
                        crashes,
                        score
                    };
                });

                if (callbacks.onDone) {
                    callbacks.onDone(scores);
                }
            }

            step();
        }

        function renderTopSegments(scores) {
            const list = document.getElementById('risk-list');
            list.innerHTML = '';

            scores
                .filter(item => item.volume > 0)
                .sort((a, b) => b.score - a.score)
                .slice(0, 12)
                .forEach((item, rank) => {
                    const row = document.createElement('div');
                    row.className = 'risk-item';
                    row.innerHTML =
                        `<strong>#${rank + 1} ${item.name}</strong>` +
                        `<div class="risk-meta">Crashes: ${item.crashes} | AWDT: ${item.volume} | Score: ${item.score.toFixed(5)}</div>`;

                    row.addEventListener('click', () => {
                        const segment = flowsWgs.features[item.index];
                        if (!segment) {
                            return;
                        }
                        const bbox = turf.bbox(segment);
                        map.fitBounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]], { padding: 40, maxZoom: 16 });
                    });

                    list.appendChild(row);
                });

            if (!list.childElementCount) {
                list.textContent = 'No non-zero traffic volume segments found.';
            }
        }

        function setupToggle(controlId, layerId) {
            const control = document.getElementById(controlId);
            const sync = () => {
                if (!map || !map.getLayer(layerId)) {
                    return;
                }
                map.setLayoutProperty(layerId, 'visibility', control.checked ? 'visible' : 'none');
                updateSummaryPanel();
            };

            control.addEventListener('change', sync);
            sync();
        }

        async function initializeMap() {
            await loadData();

            const mapStyle = {
                version: 8,
                sources: {
                    cartoDark: {
                        type: 'raster',
                        tiles: [
                            'https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                            'https://b.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                            'https://c.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png'
                        ],
                        tileSize: 256,
                        attribution: '&copy; OpenStreetMap contributors &copy; CARTO'
                    }
                },
                layers: [
                    {
                        id: 'cartoDark',
                        type: 'raster',
                        source: 'cartoDark'
                    }
                ]
            };

            map = new maplibregl.Map({
                container: 'map',
                style: mapStyle,
                center: initialView.center,
                zoom: initialView.zoom,
                attributionControl: false
            });

            map.addControl(new maplibregl.NavigationControl(), 'top-right');
            map.addControl(new maplibregl.AttributionControl({ compact: true }), 'bottom-right');

            map.on('load', () => {
                map.addSource('flows', { type: 'geojson', data: flowsWgs });
                map.addSource('collisions', { type: 'geojson', data: collisionsWgs });

                map.addLayer({
                    id: 'volume',
                    type: 'line',
                    source: 'flows',
                    paint: {
                        'line-color': [
                            'case',
                            ['>', ['coalesce', ['get', 'AWDT'], ['get', 'ADT'], 0], 40000], '#00e0ff',
                            ['>', ['coalesce', ['get', 'AWDT'], ['get', 'ADT'], 0], 25000], '#00b4ff',
                            ['>', ['coalesce', ['get', 'AWDT'], ['get', 'ADT'], 0], 12000], '#0090ff',
                            '#0070d9'
                        ],
                        'line-width': [
                            'interpolate', ['linear'], ['coalesce', ['get', 'AWDT'], ['get', 'ADT'], 0],
                            0, 1.8,
                            10000, 3,
                            25000, 4.6,
                            45000, 6.8
                        ],
                        'line-opacity': 0.9
                    }
                });

                map.addLayer({
                    id: 'risk',
                    type: 'line',
                    source: 'flows',
                    paint: {
                        'line-color': '#91cf60',
                        'line-width': 3.5,
                        'line-opacity': 0.95
                    }
                });

                map.addLayer({
                    id: 'collisions',
                    type: 'circle',
                    source: 'collisions',
                    paint: {
                        'circle-radius': [
                            'case',
                            ['==', ['get', 'SEVERITYDESC'], 'Fatal Collision'], 10,
                            ['match', ['get', 'SEVERITYDESC'], ['Serious Injury Collision', 'Serious Injury Collision '], true, false], 8,
                            6
                        ],
                        'circle-color': [
                            'case',
                            ['==', ['get', 'SEVERITYDESC'], 'Fatal Collision'], '#d7191c',
                            ['match', ['get', 'SEVERITYDESC'], ['Serious Injury Collision', 'Serious Injury Collision '], true, false], '#fdae61',
                            '#2b83ba'
                        ],
                        'circle-opacity': 0.85,
                        'circle-stroke-color': '#0b1526',
                        'circle-stroke-width': 1
                    }
                });

                const allBbox = turf.bbox(flowsWgs.features.length ? flowsWgs : collisionsWgs);
                map.fitBounds([[allBbox[0], allBbox[1]], [allBbox[2], allBbox[3]]], { padding: 40 });

                map.on('click', 'collisions', event => {
                    const properties = event.features[0].properties;
                    new maplibregl.Popup()
                        .setLngLat(event.lngLat)
                        .setHTML(
                            `<b>${properties.SEVERITYDESC || 'Collision'}</b><br>` +
                            `Date: ${properties.INCDATE || 'n/a'}<br>` +
                            `Type: ${properties.COLLISIONTYPE || 'n/a'}<br>` +
                            `Weather: ${properties.WEATHER || 'n/a'}`
                        )
                        .addTo(map);
                });

                map.on('click', 'risk', event => {
                    const properties = event.features[0].properties;
                    new maplibregl.Popup()
                        .setLngLat(event.lngLat)
                        .setHTML(
                            `<b>Risk (2022)</b><br>` +
                            `Street: ${properties.STNAME_ORD || 'Segment'}<br>` +
                            `Crashes: ${properties.crashes || 0}<br>` +
                            `AWDT: ${properties.AWDT || properties.ADT || 'n/a'}`
                        )
                        .addTo(map);
                });

                setupToggle('toggle-volume', 'volume');
                setupToggle('toggle-risk', 'risk');
                setupToggle('toggle-collisions', 'collisions');

                map.on('idle', updateSummaryPanel);
                map.on('moveend', updateSummaryPanel);
                updateSummaryPanel();
            });
        }

        document.getElementById('compute-risk').addEventListener('click', () => {
            if (!map || !map.getSource('flows')) {
                return;
            }

            const button = document.getElementById('compute-risk');
            const progress = document.getElementById('progress');

            button.disabled = true;
            button.textContent = 'Computing...';
            progress.textContent = 'Starting risk computation...';

            computeRiskAsync(flowsWgs, collisionsWgs, {
                onProgress: (done, total) => {
                    progress.textContent = `Computing risk: ${done}/${total}`;
                },
                onDone: scores => {
                    const augmentedFeatures = flowsWgs.features.map((feature, index) => {
                        const crashes = scores[index].crashes;
                        const score = scores[index].score;
                        return {
                            ...feature,
                            properties: {
                                ...feature.properties,
                                crashes,
                                risk_score: score
                            }
                        };
                    });

                    flowsWgs = {
                        ...flowsWgs,
                        features: augmentedFeatures
                    };

                    map.getSource('flows').setData(flowsWgs);

                    const nonZeroScores = scores
                        .map(item => item.score)
                        .filter(value => value > 0)
                        .sort((a, b) => a - b);

                    function quantile(percentile) {
                        if (!nonZeroScores.length) {
                            return 0;
                        }
                        const idx = Math.min(nonZeroScores.length - 1, Math.floor(percentile * nonZeroScores.length));
                        return nonZeroScores[idx];
                    }

                    const q25 = quantile(0.25) || 0.000001;
                    const q50 = quantile(0.5) || 0.000002;
                    const q75 = quantile(0.75) || 0.000003;
                    const q90 = quantile(0.9) || 0.000004;

                    map.setPaintProperty('risk', 'line-color', [
                        'step',
                        ['coalesce', ['get', 'risk_score'], 0],
                        '#cddfd0', q25, '#a9e3a0',
                        q50, '#fee08b',
                        q75, '#fdae61',
                        q90, '#d73027'
                    ]);

                    map.setPaintProperty('risk', 'line-width', [
                        'interpolate', ['linear'], ['coalesce', ['get', 'risk_score'], 0],
                        0, 3.5,
                        q25, 5,
                        q50, 6.5,
                        q75, 8,
                        q90, 10
                    ]);

                    renderTopSegments(scores);

                    progress.textContent = 'Risk ready.';
                    button.textContent = 'Recompute risk';
                    button.disabled = false;
                }
            });
        });

        document.getElementById('reset').addEventListener('click', event => {
            event.preventDefault();
            if (!map) {
                return;
            }

            map.flyTo({
                center: initialView.center,
                zoom: initialView.zoom
            });
        });

        initializeMap().catch(error => {
            console.error(error);
            document.getElementById('progress').textContent = 'Failed to load data. Check console for details.';
        });
    </script>
</body>
</html>
